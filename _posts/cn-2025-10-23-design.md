# JavaScript 设计模式（一）：从动物园到工厂 🦁

*—— 写给 2025 的前端开发者*

> 别着急，世界会等你长大。

## 一、为什么前端也要学设计模式？

设计模式最早在面向对象的软件工程领域提出，用于解决对象创建、组合等重复出现的问题。

随着前端从"做静态页面"发展为"状态管理与复杂业务交互"时代，我们也遇到了：大量组件、依赖关系、服务端联动等，导致代码难以维护，耦合度高。

再加上 AI 辅助代码生成与自动化构建工具的普及，前端代码变化更频繁、形式更多样，维护成本也更高。

**所以，学习设计模式的意义就在于：让变化的部分灵活，让不变的部分稳定。**

当然，并不是所有设计模式都适合前端。
例如 SOLID 设计原则中有五个，但在前端最常用的是"单一功能"和"开放封闭"。

接下来我会用简单生动的例子带大家慢慢理解设计模式，希望在这个焦虑的大环境里，我们能静下心来共同进步。

---

## 二、构造器模式：造一个动物园 🐒

假设你开了家动物园，要在系统中录入动物：

```js
const monkey = {
  name: 'King Kong',
  age: 1
}

const tiger = {
  name: 'Tiger', 
  age: 3
}
```

但当动物越来越多时，你的代码就成了"复制粘贴地狱"。
这时可以用 **构造函数(Constructor)** 来封装创建逻辑：

```js
class Animal {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
}

const monkey = new Animal('King Kong', 1)
const tiger = new Animal('Tiger', 3)
```

在 JavaScript 中，**构造器**（Constructor）就是用来创建和初始化对象的特殊函数。我们使用 `new` 关键字来调用它。而**构造器模式**，指的就是通过封装对象属性的初始化逻辑，来规范化对象创建的一种方式。

可以看出，每个实例化后的对象（如 `animal`）中，属性的 key（`name`, `age`）是不变的，而对应的 value（例如 `'King Kong'`, `'Tiger'`）是变化的。构造器模式通过封装赋值过程，让对象的结构固定、属性灵活，从而实现了"稳定与变化"的分离。

> **构造器模式抽象的是一个对象实例内部的'变'与'不变'；而工厂模式，则进一步抽象不同构造函数（类）之间的'变'与'不变'。**

也就是说，构造器帮我们"造一只动物"，而工厂模式帮我们"决定造哪种动物"。

当对象类型越来越多、创建逻辑越来越复杂时，仅靠构造器已经无法管理这些变化，这时就需要引入工厂模式来统一创建流程。

---

## 三、简单工厂模式 🏭

动物园提出了新需求：

> 每种动物要根据食性喜好分配不同的食物。

这样之前封装的 `Animal` 构造器就不够用了，我们需要不同的"动物类"来表示差异：

```js
class Vegetarian {
  constructor(name, age) {
    this.name = name
    this.age = age
    this.favorite = 'fruit'
    this.food = ['apple', 'banana']
  }
}

class Carnivore {
  constructor(name, age) {
    this.name = name
    this.age = age
    this.favorite = 'meat'
    this.food = ['beef', 'pork']
  }
}
```

现在问题出现了：如果动物种类越来越多，就要写越来越多的类，而且每个类中都有重复的属性（`name`, `age`）。

我们可以先提取出这些共性，然后把"不同动物吃什么"这个差异交给一个统一的函数来处理：

```js
class Animal {
  constructor(name, age, favorite, food) {
    Object.assign(this, { name, age, favorite, food })
  }
}

// 简单工厂：根据食性创建动物
const createAnimal = (type, name, age) => {
  // 使用配置对象映射，比 switch 更简洁
  const animalConfig = {
    fruit: { favorite: 'fruit', food: ['apple', 'banana'] },
    meat: { favorite: 'meat', food: ['beef', 'pork'] },
    vegetable: { favorite: 'vegetable', food: ['cabbage'] }
  }

  const config = animalConfig[type] || { favorite: 'unknown', food: [] }
  const { favorite, food } = config

  return new Animal(name, age, favorite, food)
}

// 使用起来非常简单！
const monkey = createAnimal('fruit', 'King Kong', 1)
const tiger = createAnimal('meat', 'Tiger', 3)
```

这样，无论动物种类如何增加，我们都能通过 `createAnimal()` 来统一创建。
这就是**简单工厂模式（Simple Factory Pattern）**的核心思想：

> 用一个工厂函数封装对象创建的过程，让调用者只关心"要什么"（食性类型），而不用关心"怎么造"（具体分配什么食物）。

---

## 四、现代框架中的工厂模式

其实，工厂模式早已融入我们每天写的框架代码中。

### 🔹 React 示例

```jsx
import React from 'react'
import { Button, Card } from './components'

const createComponent = (type, props) => {
  const components = {
    button: Button,
    card: Card
  }

  const Component = components[type] || 'div'
  return <Component {...props} />
}

// 使用示例
const App = () => (
  <div>
    {createComponent('button', { label: 'Click me!' })}
    {createComponent('card', { title: 'Hello React' })}
  </div>
)

export default App
```

🧠 **这就是 React 里的"组件工厂"思维**：一个函数统一管理组件创建逻辑，让调用更简洁、更动态。

### 🔹 Vue 示例

```js
import { h } from 'vue'
import AlertDialog from './AlertDialog.vue'
import ConfirmDialog from './ConfirmDialog.vue'

const createDialog = (type) => {
  const components = {
    alert: AlertDialog,
    confirm: ConfirmDialog
  }
  return h(components[type] || 'div')
}
```

🎯 **Vue 的 `h()` 函数（也叫 createElement）本质上就是"虚拟节点工厂"**，而我们的 `createDialog` 则是在此之上构建的"业务组件工厂"。

---

## 五、总结 🧩

| 模式 | 作用 | 动物园比喻 |
| :--- | :--- | :--- |
| 构造器模式 | 封装对象内部结构 | **给你一张标准表格，让你填写一只动物的信息** |
| 工厂模式 | 封装对象创建逻辑 | **你告诉管理员"我要一只吃肉的3岁老虎"，他帮你把表格填好并送来** |

| 模式 | 作用 | 示例 |
| ----- | ------------- | ------------------------------------ |
| 构造器模式 | 封装对象内部结构 | `new Animal()` |
| 工厂模式 | 封装对象创建逻辑 | `createAnimal()`、`createComponent()` |
| 核心思想 | 解耦"使用者"和"创建者" | "告诉我你要什么，我帮你造。" |

---

## 六、2025年的思考 💭

AI 可以帮你生成代码，但它不懂"**为什么要这么设计**"。
设计模式仍然是人类开发者的优势：
它教你**在变化中找规律，在复杂中找秩序**。

> 写模式，其实是在写"思考方式"。

---

## 下篇预告 🌿

下一篇我们来聊——
**《抽象工厂模式》**

当你的动物园需要扩展到不同**大洲**（亚洲动物园、非洲动物园），每个大洲都有自己独特的食物链和动物组合时，简单工厂就显得力不从心了。

抽象工厂模式将教会我们如何管理**"工厂的工厂"**，让创建逻辑本身也变得可扩展、可维护。

---

*觉得有收获？欢迎在评论区分享你的想法！我们一起进步 🚀*